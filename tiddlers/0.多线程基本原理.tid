created: 20220526081657690
creator: TidGiUser
modified: 20220526082536043
modifier: TidGiUser
title: 0.多线程基本原理
type: text/vnd.tiddlywiki
wysiwyg: yes

! 进程与线程基本原理

!! 进程

''进程是操作系统资源调度的基本单位，应用程序回以进程的形式，运行在操作系统之上，享受操作系统提供的服务''



<img ></img>
数据段是进程的操作数据在内存中的位置，包含了需要操作的数据集合;

程序控制块 PCB(Program Control Block)包含进程的描述信息和控制信息，''是进程存在的唯一标志''



PCB包含四大内容：

(1)进程的描述信息。主要包括了''进程 ID 和进程名称''——进程 ID 是唯一的，代表进程的 身份;''进程的状态——比如运行、就绪、阻塞'';''进程优先级——是进程调度的重要依据''。
(2)进程的调度信息。主要包括了''程序的入口地址''——程序的第一行指令的内存地址，从这里开始程序的执行;''通信信息''——进程间通信时的消息队列。
(3)进程的资源信息。主要包括了''内存信息''——内存占用情况和内存管理所用的数据结构; ''I/O 设备信息''——所用的 I/O 设备编号及相应数据结构;''文件句柄''——所打开文件的信息。
(4)进程上下文。主要包括了执行时的''各种 CPU 寄存器的值，当前的程序计数器(PC)值， 以及各种栈的值等''，组成进程上下文，也即进程的环境。在操作系统进程切换时，当前进程被迫让出 CPU，当前进程的上下文就保存在 PCB 结构中，''供下次恢复运行时使用''。

''现代操作系统中，进程是并发执行的，任何进程都可以同其他进程一起进行。在进程内部，代 码段和数据段，有自己的独立地址空间;不同进程的地址空间是互相隔离的''

!! java进程

Java 编写的程序都运行在 Java 虚拟机(JVM)中，每当使用 java 命令启动一个 Java 应用程序时，就会启动一个 JVM 进程。在这个 JVM 进程内部，所有 Java 程序代码的运行都是以线程来 运行的。JVM 找到程序程序的入口点 main()方法，然后运行 main()方法，这样就产生了一个线程， 这个线程称之为''主线程''。''当 main()方法结束后，主线程运行完成。JVM 进程也随即退出''

!! 线程

线程是程序执行的最小单位，是CPU调度的最小单位，''指的是“进程代码段”一次的顺序执行流程''

一个标准的线程主要由以下三个部分组成:线程描述信息、程序计数器(PC)、和栈内存组成

!! 进程与线程的区别

总结一下进程与线程的区别，主要为以下几点:
(1)线程是“进程代码段”的一次的顺序执行流程。一个进程由一个或多个线程组成;一个 进程至少有一个线程。
(2)''线程是 CPU 调度的最小单位;进程是操作系统分配资源的最小单位''。线程的划分尺度 小于进程，使得多线程程序的并发性高。
(3)线程是出于高并发的调度诉求，从进程内部演进而来。线程的出现，既充分发挥 CPU 的计算性能，弥补进程调度的过于笨重。
''(4)进程之间是相互独立的;但进程内部各个线程之间，并不完全独立。各个线程之间共享 进程的方法区内存、堆内存、系统资源(文件句柄、系统信号等等)。
(5)切换速度不同:线程上下文切换比进程上下文切换要快得多。所以，有的时候，线程也 称之为轻量级进程。''

! 创建线程的方式，4种，本质是1种

# 继承Thread类，实现run方法。使用的时候new 自定义thread类
# 实现Runnable接口，实现run方法。使用的时候new Thread类，将自定义类作为参数传入其构造方法,成Thread类中一个target属性。Thread源码中run方法如果没被覆盖，就会调用target.run()

2.1.如果Runnable接口的实现类是一次性的，不涉及复用，第2种的优雅简写：''匿名内部类或lambda表达式''

[img[截屏2021-12-13 下午1.25.49.png|0%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%2065987c03ec134bcba8c23a8610aa7a64/%E6%88%AA%E5%B1%8F2021-12-13_%E4%B8%8B%E5%8D%881.25.49.png]]

runnable的好处：

# ''线程创建与任务的定义解耦，这样就不用来一个新任务就创建一个新线程''，也就让线程池的使用成为了可能。
# 继承了thread就不能继承别的类了
# 1,2的缺点是：不能获取异步执行的结果，我想让线程运行结束之后返回给我一个值，用静态变量？？？这样不灵活，所以你可以用callable，''Callable 一般会和线程池一起使用''

''Callable接口是一个函数式接口，也是一个泛型接口，只有一个方法call，返回泛型''

但是，如果不用线程池，自己创建Thread，callable不能直接传给Thread，只能传FutureTask

Callable接口看起来类似于Runnable接口，只不过一个有返回值一个没返回值，''但是Callable接口不能作为参数直接传给Thread类''，需要''RunnableFuture接口''做搭桥

从下面的图看，FutureTask具有Runnable的特性，''能够定义任务，又具有Future的特性，能够获取未来异步执行的结果''。

[img[Untitled|0%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%2065987c03ec134bcba8c23a8610aa7a64/Untitled.png]]

再说一下，Future接口，至少提供了3大功能：

# 能够取消异步执行中的任务 cancel
# 判断异步任务是否完成 isDone
# 获取异步任务完成后的结果 get ，可以是无限阻塞式的，或者有时限的阻塞式
# 线程池创建线程

使用Executors静态工厂创建不同的线程池

[ext[线程池（基于bugstack）|https://www.notion.so/bugstack-38afe784baf84bef8ef4a2bde7b6202a]]

[ext[31 线程池|https://www.notion.so/31-ff249dfeb3514611b6eab812efef27d0]]

[ext[线程池在美团中的应用|https://www.notion.so/6c14c287dda14575bec4f0aa45427c85]]

! 线程核心原理：时间片与优先级

注意：优先级高只是获得执行机会的概率更高

! 线程状态（getState）（结合Thread类常用方法）

!! 6种基本状态

# NEW ： 线程刚刚创建，还没有启动
# RUNNABLE ： 可运行状态，由线程调度器可以安排执行
# * 包括READY和RUNNING两种细分状态
# WAITING： 等待被唤醒
# TIMED WAITING： 隔一段时间后自动唤醒
# BLOCKED： 被阻塞，正在等待锁  (''CAS的锁不会进入BLOCKED'')
# TERMINATED： 线程结束

[img[Untitled|0%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%2065987c03ec134bcba8c23a8610aa7a64/Untitled%201.png]]

!! 停止线程的方案

# 三个方法

[img[截屏2021-12-13 下午1.52.59.png|0%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%2065987c03ec134bcba8c23a8610aa7a64/%E6%88%AA%E5%B1%8F2021-12-13_%E4%B8%8B%E5%8D%881.52.59.png]]

# 中断异常的处理：''wait sleep join能响应，锁基本不能响应''

注意：响应了，抛出中断异常之后，标记位会被清除。

停止线程的方案，

1.interrupt

# 被停止方，也就是线程执行方最了解自己什么情况下可以停止线程，在停止线程之前应该做哪些工作以确保数据的完整性。。因此停止线程的工作应当是请求方，被停止方，被调用方三方配合的工作
## 请求方应当用interrupt通知，而不是用stop
## 被停止方应该注意在代码的适当地方响应interrupt，确保自己在适当的位置能够被停止
## 中断异常的处理：被调用的子方法，应当抛出中断异常（''让调用方决定异常处理逻辑''），或者恢复中断异常（''catch中重新调用interrupt方法''）


2.volatile

[img[截屏2021-12-13 下午2.04.14.png|0%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%2065987c03ec134bcba8c23a8610aa7a64/%E6%88%AA%E5%B1%8F2021-12-13_%E4%B8%8B%E5%8D%882.04.14.png]]

为什么不建议stop：

stop太粗暴，会直接释放所有锁，操作的原子性会被直接破坏，很容易造成数据不一致的问题。

为什么不建议suspend resume：

suspend不释放锁，容易死锁

!! 使用jstack工具查看线程状态（jvm？？？）

有时，服务器 CPU 占用率会一直很高，甚至一直处于 100%。如果 CPU 使用率居高不下， 自然是有某些线程一直占用着 CPU 资源，那又如何查看占用 CPU 较高的线程?或者说，如何查 看到线程的状态呢?一种比较快捷的办法是 Jstack 工具。

Jstack 命令的语法格式:
jstack //pid表示Java进程id，可以用jps命令查看

//[img[截屏2022-05-25 19.39.47.png|0%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%2065987c03ec134bcba8c23a8610aa7a64/%E6%88%AA%E5%B1%8F2022-05-25_19.39.47.png]]//

! 线程基本操作

!! 命名，用于回溯异常

!! Thread.sleep(time)操作

# Thread.sleep(time)进入timed\_waiting状态，让出cpu
# 调用了sleep的线程能够响应中断异常，一般如果是被调用方（给别人写模块），应该把中断异常再向外抛出，因为我们不清楚调用方的异常处理逻辑

!! thread.interrupt()方法

并不是终止线程，而是设置目标线程的中断标识位，相当于通知其终止，因为只有目标线程自己清楚该怎么停止线程，停止之前需要做怎样的处理

# 如果是running状态的线程，可以调用isInterrupted判断自己是否被中断
# Object.//''//wait() Thread.sleep(time) Thread.join()能响应，锁基本不能响应中断异常，换句话说time\_waited和waiting状态能响应interrupt方法，并且会退出阻塞，并且会重置中断标志位//''//

!! thread.join或thread.join(time)

场景：//''//thread1对thread2执行有依赖，需要thread2先执行完（或者超时之后），自己再执行//''//

使用 join 方法的优势是比较简单，劣势是 join 方法没有办法直接取得乙方线程的执行结果。

//[img[截屏2022-05-25 19.50.44.png|0%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%2065987c03ec134bcba8c23a8610aa7a64/%E6%88%AA%E5%B1%8F2022-05-25_19.50.44.png]]//

//''//注意：调用thread2.join(time)，并不能保证thread1在time时间后一定变为runnable//''//

!! Thread.yield()

作用：是让目前正在执行的线程放弃当前的执行，让出 CPU 的 执行权限，使得 CPU 去执行其他的线程。处于让步状态的 JVM 层面的线程状态，仍然是 RUNNABLE 可执行状态;//''//但是，该线程所对应的操作系统层面的线程，在状态上来说，会从执 行状态变成就绪状态。//''//

线程在 yield 时，线程放弃和重占 CPU 的时间是不确定的，可能是刚刚放 弃 CPU，马上又获得 CPU 执行权限，重新开始执行。

//''//注意：yield 不能保证使得当前正在运行的线程迅速转换到就绪状态。//''//

!! 守护线程 thread.setDaemon

//''//用户线程和 JVM 进程是主动关系— —如果全部的用户线程终止，JVM 虚拟机进程也随之终止;//''//

//''//守护线程和 JVM 进程是被动关系— —如果 JVM 进程终止，所有的守护线程也随之终止。//''//

换个角度来理解，守护线程提供服务，是守护者。用户线程享受服务，是被守护者。只有全 部的用户线程终止了，相当于没有了被守护者，守护线程也就没有工作可做了，也可全部终止了

要点：

(1)守护线程必须在启动前，将其守护状态设置为 true;启动之后，不能再将用户线程设置 为守护线程。否则，JVM 会抛出一个 InterruptedException 异常。具体来说，如果线程为守护线程，必须在线程实例的 start()方法调用之前，调用线程实例的 setDaemon(true)，设置其 daemon 实例属性值为 true。
(2)//''//守护线程存在被 JVM 强行终止的风险//''//，所以，在守护线程中//''//尽量不去访问系统资源//''//， 如文件句柄、数据库连接等等。守护线程被强行终止时，可能会引发系统资源操作的不负责任的 中断，从而导致资源不可逆的损坏。
(3)守护线程创建的线程，也是守护线程。在守护线程中创建的线程，新的线程都是守护线程。在创建之后，如果通过调用 setDaemon(false)将新的线程显示的设置为用户线程，新的线程可以调整成为用户线程。

!! wait notiy park unpark???
//