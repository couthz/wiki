created: 20220527083900492
creator: TidGiUser
modified: 20220531055715542
modifier: TidGiUser
tags: 线程池 ?
title: 11.线程池源码ThreadPoolExecutor
type: text/vnd.tiddlywiki

! 应该有的几个疑问
1. 线程池如何接受任务？

2. 线程如何运行任务？

3. 线程池如何关闭？

! 高3位与低29位,状态与线程数量
在 ThreadPoolExecutor 线程池实现类中，使用 AtomicInteger 类型的 ctl 记录线程池状态和线程数量
[img[image.png]]
RUNNING：运行状态，接受新的任务并且处理队列中的任务。

SHUTDOWN：关闭状态(调用了shutdown方法)。不接受新任务,但是要处理队列中的任务。

STOP：停止状态(调用了shutdownNow方法)。不接受新任务，也不处理队列中的任务，并且要中断正在处理的任务。

TIDYING：所有的任务都已终止了，workerCount为0，线程池进入该状态后会调 terminated() 方法进入TERMINATED 状态。

TERMINATED：终止状态，terminated() 方法调用结束后的状态。

! execute()提交
```
这里的一个疑问？？如果已创建的线程数到达了核心线程数，但是有空闲的线程，此时任务是进入队列还是直接用空闲线程运行？？？
感觉要看一看后面的runworker代码
```


```
分为三步：
1. 如果当前工作线程数（包不包括空闲的？？）小于核心线程数，尝试启动一个新线程处理任务。addWorker方法会检查线程池状态和worker（？？）的数量，避免不该添加时添加线程。
2. 如果任务进入了队列，需要二次检查。。
3. 如果队列满了，需要创建新线程，如果失败？？
        /*
         * Proceed in 3 steps:
         *
         * 1. If fewer than corePoolSize threads are running, try to
         * start a new thread with the given command as its first
         * task.  The call to addWorker atomically checks runState and
         * workerCount, and so prevents false alarms that would add
         * threads when it shouldn't, by returning false.
         *
         * 2. If a task can be successfully queued, then we still need
         * to double-check whether we should have added a thread
         * (because existing ones died since last checking) or that
         * the pool shut down since entry into this method. So we
         * recheck state and if necessary roll back the enqueuing if
         * stopped, or start a new thread if there are none.
         *
         * 3. If we cannot queue task, then we try to add a new
         * thread.  If it fails, we know we are shut down or saturated
         * and so reject the task.
         */
```

```java
    public void execute(Runnable command) {
        if (command == null)
            throw new NullPointerException();
        int c = ctl.get();
        if (workerCountOf(c) < corePoolSize) {
            if (addWorker(command, true))
                return;
            c = ctl.get();
        }
        if (isRunning(c) && workQueue.offer(command)) {
            int recheck = ctl.get();
            if (! isRunning(recheck) && remove(command))
                reject(command);
            else if (workerCountOf(recheck) == 0)
                addWorker(null, false);
        }
        else if (!addWorker(command, false))
            reject(command);
    }
```
[[CAS]]
