created: 20220610084203854
creator: TidGiUser
difficulty: 5
due: 20220614075157350
grade: -1
history: []
interval: 0
lapses: 0
modified: 20220612075157351
modifier: TidGiUser
reps: 1
retrievability: 1
review: 20220612075157350
stability: 2
tags: netty fx java基础 ?
title: 40.序列化与反序列化
type: text/vnd.tiddlywiki

! 什么是序列化和反序列化

序列化：将java的pojo对象转换为字节序列，保存在远端或者磁盘。''最关键的是：能够随时随地恢复成原来的pojo对象''

反序列化：反过来的过程

注意：序列化并不是简单的把内存中的二进制数据直接保存起来，如果单纯把堆内对象直接保存，那么引用类型仅仅是存了个地址。那么其实可以递归地把引用的数据都保存了

''但是这样还不能保存引用关系''，比如A引用了C，B引用了C，一定要保证序列化和反序列化之后，A和B引用的还是同一个C

此外，序列化一定还涉及一些策略：比如某些缓存对象并不需要存储，要标记成不序列化。

! 序列化和编码的关系

编码是一个更加宽泛的概念，可以是pojo->二进制,也可以是pojo->pojo，也可以是二进制->二进制。''一般来说就是一种形式转另一种形式，但是编码一般是把有意义的变为无意义的，目的可能是传输、压缩、加密''

因此可以理解为，序列化是编码的一种

[img[截屏2022-06-10 16.58.27.png]]

! 序列化常用方式及选型

[[美团的详细介绍|https://tech.meituan.com/2015/02/26/serialization-vs-deserialization.html]]

1. 使用Java内置的编码和序列化机制，可移植性强，性能稍差，无法跨平台(语言)。

从实验结果上来看，java内置的序列化writeObject,''不仅能够保存数据，也能把引用关系保存下来，不会重复保存相同的对象''，估计是通过seriliazeID实现的

[img[截屏2022-06-10 16.46.32.png]]

2. 使用JSON。将Java POJO对象转换成JSON结构化字符串。基于HTTP协议，在Web 应用、移动开发方面等，这是常用的编码方式，因为JSON的可读性较强。但是它 的性能稍差。

<<<
可读性的用途：

序列化和反序列化的数据正确性和业务正确性的调试往往需要很长的时间，良好的调试机制会大大提高开发效率。序列化后的二进制串往往不具备人眼可读性，为了验证序列化结果的正确性，写入方不得同时撰写反序列化程序，或提供一个查询平台–这比较费时；另一方面，如果读取方未能成功实现反序列化，这将给问题查找带来了很大的挑战–难以定位是由于自身的反序列化程序的bug所导致还是由于写入方序列化后的错误数据所导致。对于跨公司间的调试，由于以下原因，问题会显得更严重：

第一、支持不到位，跨公司调试在问题出现后可能得不到及时的支持，这大大延长了调试周期。

第二、访问限制，调试阶段的查询平台未必对外公开，这增加了读取方的验证难度。

如果序列化后的数据人眼可读，这将大大提高调试效率， XML和JSON就具有人眼可读的优点。


<<<

3. 基于XML。和JSON一样，数据在序列化成字节流之前都转换成字符串。可读性 强，性能差，异构系统、Open API类型的应用中常用。

4. 开源的二进制的序列化/反序列化框架，例如Apache Avro，Apache Thrift、 Protobuf等。前面的两个框架和Protobuf相比，性能非常接近，而且设计原理如出一辙;''其中Avro在大数据存储(RPC数据交换、本地存储)时比较常用;Thrift的 亮点在于内置了RPC机制，所以在开发一些RPC交互式应用时，客户端和服务器 端的开发与部署都非常简单''。


如何选择序列化/反序列化框架呢?评价一个序列化框架的优缺点，大概从两个方面着手:

(1)结果数据大小，原则上说，序列化后的数据尺寸越小，传输效率越高。 

(2)结构复杂度，这会影响序列化/反序列化的效率，结构越复杂，越耗时。 

理论上来说，对于对性能要求不是太高的服务器程序，可以选择JSON文本格式的序列化框架;对于性能要求比较高的服务器程序，则应该选择传输效率更高的二进制序列化框架，建议是Protobuf。

Protobuf是一个高性能、易扩展的序列化框架，性能比较高，其性能的有关的数据可以 参看官方文档。Protobuf本身非常简单，易于开发，''而且结合Netty框架，可以非常便捷地 实现一个通信应用程序。反过来，Netty也提供了相应的编解码器，为Protobuf解决了有关 Socket通信中“半包、粘包”等问题''。

当然，无论是使用JSON、Protobuf还是其他的传输协议，我们必须保证在数据包的反 序列化之前，接收端的ByteBuf二进制数据包一定是一个完整的应用层二进制包，不能是一 个半包或者粘包，这就涉及到通信过程中的拆包技术。