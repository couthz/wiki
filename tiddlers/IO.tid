created: 20220601154935211
creator: TidGiUser
difficulty: 5
due: 20220610080822119
grade: -1
history: []
interval: 0
lapses: 0
modified: 20220608080822120
modifier: TidGiUser
reps: 1
retrievability: 1
review: 20220608080822119
stability: 2
tags: 技术 fx ?
title: IO
type: text/vnd.tiddlywiki

! 总结一下[[用户态和内核态]]
为什么要区分：对于以前的 DOS 操作系统来说，是没有内核空间、用户空间以及内核态、用户态这些概念的。可以认为所有的代码都是运行在内核态的， 因而：

1. 用户编写的应用程序代码可以很容易的让操作系统崩溃掉（操作系统的代码要比应用程序的代码健壮很多），而且权限大，病毒入侵很容易

2. 另外写程序很麻烦，用户要直接和硬件打交道，记端口，没有将硬件进行抽象

总之，用户态进程 不能访问内核空间中的数据，也不能直接调用内核函数的。内核态进程可以执行任意命令，调用系统的一切资源

! read和write系统调用
用户程序进行IO的读写，依赖于底层的IO读写，基本上会用到底层的read&write两大系统调用。''应用程序的IO操作''，Linux系统中的用户程序的IO读写程序，在大多数情况下，并没有进行实际的IO操作，而是在用户缓冲区和内核缓冲区之间直接进行数据的交换。

read&write两大系统调用，都不负责数据在内核缓冲区和物理设备(如磁盘、网卡等)之间的交换。''这项底层的读写交换操作，是由操作系统内核(Kernel)来完成的''。所以，应用程序中的IO操作，无论是对Socket的IO操作，还是对文件的IO操作，''都属于上层应用的开发，它们的在输入(Input)和输出(Output)维度上的执行流程，都是类似的，都是在 内核缓冲区和进程缓冲区之间的进行数据交换。''

{{缓冲区}}