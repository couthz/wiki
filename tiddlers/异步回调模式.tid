created: 20220601005204081
creator: TidGiUser
difficulty: 6.1000000000000005
due: 20220611003503052
grade: 0
history: [{"due":"20220610080814330","interval":0,"difficulty":5,"stability":2,"retrievability":1,"grade":-1,"lapses":0,"reps":1,"review":"20220608080814330"}]
interval: 2
lapses: 1
modified: 20220610003503052
modifier: TidGiUser
reps: 1
retrievability: 0.9
review: 20220610003503052
stability: 1.4816364413634358
tags: 技术 fx ?
title: 异步回调模式
tmap.id: a667aeeb-bb33-4a92-abcc-ea51a8ac5007
type: text/vnd.tiddlywiki

! 异步回调说的是两件事情

异步指的是调用方发起IO请求的方式

回调指的是调用方如何获得异步处理完成后的结果


! 概述：

随着业务模块系统越来越多，各个系统的业务架构变得越来越复杂，特别是这几年微服务架构的兴起，''跨机器跨服务的接口调用，越来越频繁''。打个简单的比方:现在的一个业务流程，可能需要调用 N 次第三方接口，获取 N 种上游数据。因此，面临一个大的问题是:''如何异步去调取这些接口(做到高效率)，然后同步去处理这些接口的返回结果呢（异步，回调说的应该是两件事）''?这里，涉及到线程的异步回调问题，这也是高并发的一个基础问题。

在 Netty 源码中，大量的使用了异步回调技术，并且基于 Java 的异步回调，设计了自己的一 整套异步回调接口和实现。
这里，从 java future 异步回调技术入手，然后介绍比较常用的第三方异步回调技术——谷歌 的 guava future 相关技术，最后介绍一下 Netty 的异步回调技术。

! 案例：泡茶

为了异步执行整个泡茶流程，分别设计三条线程:泡茶线程(主线程)、烧水线程、清洗线程。

(1)泡茶线程(MainThread)的工作是:启动清洗线程、启动烧水线程，等清洗、烧水的工作完成后，泡茶喝;

(2)清洗线程(WashThread)的工作是:洗茶壶、洗茶杯;

(3)烧水线程 (HotWarterThread)的工作是:洗好水壶，灌上凉水，放在火上，一直等水烧开。

!! java原生的异步阻塞模式：join和FutureTask
join和futureTask的使用，可以参考以前的卡片：

join:

[[30.线程状态,Thread类常用方法]]

futureTask:

[[20.创建线程的方式]]

futureTask比join高明的地方，无非是可以获取异步调用的结果，但是，''两者都是异步阻塞的（当然调用futureTask的get之前，主线程也可以干别的事情，但是调用get后仍然会阻塞）'' 

原生Java API，除了阻塞模式的获取结果外，并没有实现非阻塞的异步结果获取方法。 如果需要用到获取异步的结果，得引入一些额外的框架，这里首先介绍谷歌的 Guava 框架

!! 另一种获取结果的方式：回调
主动调用是一种阻塞式调用，它是一种单向调用，“调用方”要等待“被调用方”执行完毕 才返回。如果“被调用方”的执行的时间很长，那么“调用方”线程需要阻塞很长一段时间。

如何将主动调用的方向进行反转呢?这就是异步回调。回调是一种反向的调用模式，也就是 说，被调用方在执行完成后，会反向执行“调用方”所设置的钩子方法。

Java 中回调模式的标准实现类为 CompletableFuture，''由于该类出现的时间比较晚，所以很 多的著名的中间件如 Guava、Netty 等都提供了自己的异步回调模式 API 供开发者们使用''。开发者还可以使用 RxJava 响应式编程组件进行异步回调的开发。



---
这里会联想到一些概念：

1. [[reactor模式和观察者模式的区别|https://stackoverflow.com/questions/26454642/observer-pattern-vs-reactor-pattern]]

- - - - -

2. ''关于异步调用之后如何获得结果的问题：''
观察者模式：

订单中心执行了异步的操作之后，他要去对其他的中心注册一个观察者，等待其他中心完成操作之后，将结果通知给订单中心

经典应用：分布式协调，异步调用之后，如果调用者想知道结果怎么办？？

1. 专门开个通知接口，麻烦

2. 轮询，更麻烦

3. 发送完异步消息之后，直接监听一个东西，系统B处理完之后，触发一下系统A的监听器，通知系统A处理的结果

*如果是跟jvm队列结合，用jdk的监听器。如果是分布式队列，就用zk

- - - - - 

3. 关于同步、异步、阻塞、非阻塞
[[同步、异步、阻塞、非阻塞]]

4. 关于用户态内核态
[[用户态和内核态]]